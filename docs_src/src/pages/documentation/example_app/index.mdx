export const description =
  'Welcome to the Robyn API documentation. You will find comprehensive guides and documentation to help you start working with Robyn as quickly as possible, as well as support if you get stuck.'

# Real Life Web Apps with Robyn

Batman was tasked with building a web application to manage the crime data in Gotham City. The application would allow the Gotham police department to store and retrieve data on criminal activities, suspects, and their locations. He decided to use the Robyn web framework to build this application efficiently and quickly.

You can find the source code for this application [here](https://github.com/sparckles/example_robyn_app).

## Installing Robyn

The first step was to install Robyn. Batman created a virtual environment and installed Robyn using pip.

```bash
$ python3 -m venv venv
$ source venv/bin/activate
$ pip install robyn
```

## Creating a Robyn Application

Batman wanted to create a Robyn app and was about to create an `src/app.py` before he was told that Robyn comes with a CLI tool to create a new application. He ran the following command to create a new Robyn application.

```bash
$ python -m robyn --create
```

You can choose to have a simple barebones format or an structured scaffold (recommended) ike so...

```bash
$ python -m robyn --create
? Directory Path: myproject
? Need Docker? (Y/N) Y
? Please choose if you'd like the scaffold to be a simple starter kit or an opinionated structure
  Simple
❯ Structured
```


This, would result in the following output if you choose scaffold type as `simple`

```bash
$ python3 -m robyn --create
? Directory Path: .
? Need Docker? (Y/N) Y
? Please choose if you would like the scaffold to be a barebones starter kit or a recommended structure
? Please select project type (Mongo/Postgres/Sqlalchemy/Prisma):
❯ No DB
  Sqlite
  Postgres
  MongoDB
  SqlAlchemy
  Prisma
```

and the following directory structure.


Batman was asked a set of questions to configure the application. He chose to use the default values for most of the questions.

And he was done! The Robyn CLI created a new application with the following structure.

```bash

├── src
│   ├── app.py
├── Dockerfile

```


<div className="not-prose">
  <Button
    href="/documentation/example_app/modeling_routes"
    variant="text"
    arrow="right"
    children="Modeling Routes"
  />
</div>

If you choose to go with the structured scaffold, this is how your project will look like

> note: at the moment, only no-db and sqlalchemy are supported here, you can always plug in other integrations as you see fit

```bash
├── adaptors
│   ├── __init__.py
│   ├── models
│   │   ├── __init__.py
│   │   └── user.py
│   ├── mutators
│   │   └── __init__.py
│   └── selectors
│       ├── __init__.py
│       └── misc.py
├── alembic.ini
├── api
│   ├── handlers
│   │   ├── __init__.py
│   │   ├── probes.py
│   │   └── sample.py
│   └── middlewares
│       └── __init__.py
├── conf.py
├── config.env
├── devops
│   ├── Dockerfile
│   ├── Dockerfile.src
│   └── docker-compose.yaml
├── migrations
│   ├── README
│   ├── env.py
│   ├── script.py.mako
│   └── versions
│       └── __init__.py
├── requirements.txt
├── server.py
└── utils
    ├── __init__.py
    └── db.py

12 directories, 24 files
```

Here's what each of these stand for

- server.py

This is where you instantiate your robyn server and inject global dependencies

```python
from robyn.helpers import discover_routes
from robyn import Robyn

from utils.db import get_pool
from conf import settings

app: Robyn = discover_routes("api.handlers")
# note: if you prefer to manuall refine routes, use your build_routes function instead

app.inject_global(pool=get_pool())


if __name__ == "__main__":
    app.start(host="0.0.0.0", port=settings.service_port)
```

- conf.py/config.env

Comes with initial settings you need to work with the database. The `BaseConfig` class slight enhancement on pydantic-settings's `BaseSettings` class

- Your endpoint and middleware handlers live under the `api` package.
> note: the example where the handlers are in a class as static methods is completely up to the developer preference and doesn't impact the actual routing in any way

- It also comes pre-configured with alembic for database migrations

- The database mutations and queries will be living under the `adaptors` package where you would do the following
  - define your sqlalchemy and pydantic models
  - define selectors for reusable query functions
  - define mutators for any mutations over the model along with related functionality, usually in a transaction block

> note: by default, we include sqlalchemy async pool, you can always change it as per your requirements


